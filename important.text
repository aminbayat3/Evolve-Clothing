<Routes>
    <Route path="/" element={<Navigation />}>
        <Route index element={<HomePage />} />
        <Route path="shop" element={<Shop />} />
    </Route>
</Routes>

***********************************************
import { Fragment } from 'react';
import { Outlet } from 'react-router-dom';

import './navigation.styles.scss';

//Fragments let you group a list of children without adding extra nodes to the DOM. if i used a div instead of Fragment that div would be redundent.
const Navigation = () => {
    return(
        <Fragment>
            <div className='navigation'>
                <h1>I am the navigation bar</h1>
            </div>
            <Outlet />
        </Fragment>
    )
}

export default Navigation;

*******************************************'
{
 // isCartOpen ? (<CartDropdown />) : null
 isCartOpen && <CartDropdown />  
} 
//short circuit operator(&& , ||) && => double ampersand // components are always truthy values because they are functions//
 so the short circuit operator says if this total thing (the whole code inside of the curly braces) evaluates to true, then what im gonna return to you is going to be the last thing you gave me.

 ////////////////////////////////////

 import { useNavigate } from 'react-router-dom'; instead of withRouter

const navigate = useNavigate();
//////////////////////////////////////////////

**********************************************
** IMPORTANT POINT FOR PREVENTING UNNECESSARY RENDERS IN OUR APPLICATION
  const categoriesMap = useSelector(selectCategoriesMap); // this useSelector will run every time the state object in root reducer has updated(whether it is currentUser or categories) and it only force the component to re-render if the return of the selector function you pass to it is different,
 and given the fact that the selector always return a new object it will lead to unnecssary re-renders. 
 the solution is to make the selector function runs only when the categories changes. and this is viable via using a library called Reselect. 

 **************************************************

 import { createSelector } from 'reselect'; // this makes our selector, a memoized one. a memoization is the process in which you cache the previous value of something so that if the input has not changed then you just return back the same output

 *****************************************************
Boolean(10) is true
Boolean("GeeksforGeeks") is true
Boolean(2.74) is true
Boolean(-1) is true
Boolean('true') is true
Boolean('false') is true
Boolean(3 * 2 + 1.11) is true
Boolean(1<2) is true
************************************
Boolean(0) is false
Boolean("") is false
Boolean(e) undefined is false
Boolean(-0) is false
Boolean(false) is false
Boolean(NaN) is false
Boolean(null) is false
Boolean(1>2) is false
******************************************
NODE_ENV as performance booster: One of the simplest things we can do to improve performance is to set NODE_ENV to “production”. 

Setting NODE_ENV to “production” makes Express:

Cache view templates.
Cache CSS files generated from CSS extensions.
Generate less verbose error messages.

process.env.NODE_ENV is either devlopment or production //
const middleWares = [process.env.NODE_ENV === 'devlopment' && logger].filter((x) => Boolean(x)) we use this filter to filter out any false value that gets returned if it was on the production mode because we can't pass false as our middleWares array

for example: 
2 === 3 && { a: 'string' } // this will give us back false value
[2 === 3 && { a: 'string' }].filter(Boolean); // it's gonna give us back an empty array because that Boolean function gets rid of all the falsy values

***********************************************************
call effect(saga): anywhere you're going to call a function, you want to use the call effect generator
now inside of redux saga every single step that yields you want to be as descriptive as possible
now descriptive here essentially means creating an effect for it that's why these are called effect generators
an effect is essentially a plain object that describes what's trying to happen, so here with call
this is just gonna say: hey i've got some object where the function name is going to be "createUserDocumentFromAuth"(eg) and then it's gonna say
the params are .... just like this : => 
{ 
    fn: createUserDocumentFromAuth,
    params: [],
}
this plain object above is an effect. ( this might not be the shape, but this just gives you an idea)

why is it useful ::: what this allows us to do is actually makes testing easier when we're going to test sagas, but 
also we're just essentially handing over the execution of this API call or any of this code to our actual generator
and you want to hand over as much of the generator as you can because the generator is gonna be the one that cancel these.
*****************************************************************